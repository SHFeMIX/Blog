# 模块查找策略

模块查找策略指的是，当代码中使用 ES module 模块化规范导入一个模块时，Node.js 如何根据模块标识符找到对应的模块文件。

## 模块标识符

在一个 ```import``` 导入语句中, **模块标识符**指的是关键字 ```from``` 后面跟着的字符串，例如 ```import { sep } from 'node:path``` 中的 ```node:path```。```export from``` 语句和 ```import()``` 表达式中也使用了标识符。

模块标识符共有三种形式：

* 相对标识符：例如 ```'./startup.js'``` 或者 ```'../config.mjs'```，指的是要导入的模块相对于当前文件的路径。注意，相对标识符必须包含文件扩展名。

* 裸模块标识符：例如 ```'some-package'``` 或者 ```'some-package/shuffle'```，通过包名字指向包的主入口，或者包内某个具体的模块，就像第二个例子中所示的那样。只有导入的包的 ```packehs.json``` 文件中未指定 ```"exports"``` 字段时，裸模块标识符才必须包含文件扩展名。

* 绝对标识符：例如 ```'file:///opt/nodejs/config.js'```，直接且明确地引用完整路径。

裸模块标识符通过 [Node 标识符解析算法](#标识符解析算法) 处理，其他类型的标识符则直接根据 [URL 现行标准](https://url.spec.whatwg.org/) 进行解析。

在标识符中的包名后加文件路径，可以访问包中的具体模块文件，例如 ```'some-package/shuffle'```。然而，如果包的 ```package.json``` 文件包含 ```"exports"``` 字段，则只能访问 ```"exports"``` 字段中明确列出的文件路径。

## 标识符解析算法

下面我们将通过实现一个函数 **ESM_RESOLVE** 来模拟 Node 解析 ES modules 标识符的算法，它会返回解析模块标识符得到的相对于当前文件路径的 URL。

```js
const defaultConditions = ['node', 'import']

function ESM_RESOLVE(specifier, parentURL) {
    // 1. 让 resolved 变量等于 undefined
    let resolved = undefined

    // 2. 如果标识符是合法 URL
    if (isValidURL(specifier)) {
        // 2.1 把标识符当作 URL 进行解析和序列化，赋值给 resolved
        resolved = new URL(specifier, parentURL).href
    }
    // 3. 如果标识符是 '/'、'./' 或者 '../' 开头
    else if (specifier.startsWith('/') || specifier.startsWith('./') || specifier.startsWith('../')) {
        // 3.1 把 resolved 赋值为标识符相对于当前文件路径的解析结果
        resolved = resolveURL(specifier, parentURL)
    }
    // 4. 如果标识符是 ‘#’ 开头
    else if (specifier.startsWith('#')) {
        // 4.1 把 resolved 赋值为调用 PACKAGE_IMPORTS_RESOLVE 函数的结果
        resolved = PACKAGE_IMPORTS_RESOLVE(specifier, parentURL, defaultConditions)
    }
    else {
        // 5. 如果上述情况都不符合
        // 5.1 注意：此时的标识符是裸模块标识符
        // 5.2 把 resolved 赋值为调用 PACKAGE_RESOLVE 函数的结果
        resolved = PACKAGE_RESOLVE(specifier, parentURL)
    }

    // 6. 把 format 赋值为 undefined
    let format = undefined

    // 7. 如果 resolved 是一个 'file:' 开头的 URL
    if (resolved.startsWith('file:')) {
        // 7.1 如果 resolved 包含 "/" 或 "\" 的百分比编码（"%2F 或 "%5C"）
        if (resolved.includes('%2F') || resolved.includes('%5C')) {
            // 7.1.1 报错 Invalid Module Specifier
            throw new ERR_INVALID_MODULE_SPECIFIER()
        }

        // 7.2 如果 resolved 是一个文件夹
        if (isDirectory(resolved)) {
            // 7.2.1 报错 Unsupported Directory Import
            throw new ERR_UNSUPPORTED_DIR_IMPORT()
        }

        // 7.3 如果 resolved 指向的文件不存在
        if (!isFileExists(resolved)) {
            // 7.3.1 报错 Module Not Found
            throw new ERR_MODULE_NOT_FOUND()
        }

        // 7.4 把 resolved 赋值为 它的真实路径，保留 URL参数和分隔符号
        resolved = toRealPath(resolved)

        // 7.5 把 format 赋值为调用 ESM_FILE_FORMAT 函数的结果
        format = ESM_FILE_FORMAT(resolved)
    }
    else {
        // 8. 否则
        // 8.1 把 format 赋值 resolved URL 对应的 content type 的格式
        format = getFormat(resolved)
    }

    // 9. 返回 format 和 resolved 交给模块加载器
    return { format, resolved }
}

function PACKAGE_RESOLVE(specifier, parentURL) {
    // 1. 把 packageName 赋值为 undefined
    let packageName = undefined

    // 2. 如果 specifier 是空字符串
    if (specifier === '') {
        // 报错 Invalid Module Specifier
        throw new ERR_INVALID_MODULE_SPECIFIER()
    }

    // 3. 如果 spceifier 是一个 Node 内部模块名称
    if (isNodeBuiltinModule(specifier)) {
        // 将字符串 'node:' 和 specifier 拼接并返回
        return `node:${specifier}`
    }

    // 4. 如果 specifier 不是 '@' 开头
    if (!specifier.startsWith('@')) {
        // 4.1 把 packageName 赋值为 specifier 的第一个 '/' 之前的子字符串，没有就是它自己
        const packageName = specifier.split('/', 1)[0]
    }

    // 5. 否则
    else {
        // 5.1 如果 packageName 不包含 '/'
        if (!packageName.includes('/')) {
            // 5.1.1 报错 Invalid Module Specifier
            throw new ERR_INVALID_MODULE_SPECIFIER()
        }

        // 5.2 把 packageName 赋值 specifier 的为第二个 '/' 之前的子字符串，没有就是它自己
        packageName = specifier.split('/', 2).join('/')
    }

    // 6. 如果 packegaName 以 "." 开头，或者包含 "\" 或者 "%"
    if (packageName.startsWith('.') || packageName.includes('\\') || packageName.includes('%')) {
        // 6.1 报错 Invalid Module Specifier
        throw new ERR_INVALID_MODULE_SPECIFIER()
    }

    // 7. 把 字符串 "." 与 specifier 从 packageName 长度开始的子字符串拼接，赋值给 packegeSubpath  
    const packageSubpath = '.' + specifier.substring(packageName.length)

    // 8. 把 selfUrl 赋值为 PACKAGE_SELF_RESOLVE 函数的调用结果
    const selfUrl = PACKAGE_SELF_RESOLVE(packageName, packageSubpath， parentURL)

    // 9. 如果 selfUrl 不是 undefined， 返回 selfUrl
    if (selfUrl !== undefined) {
        return selfUrl
    }

    // 10
}
```