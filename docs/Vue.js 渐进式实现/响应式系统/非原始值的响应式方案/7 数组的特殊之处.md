# 数组的特殊之处

从本节开始，我们讲解如何代理数组。实际上，在 JavaScript 中，数组只是一个特殊的对象而已，因此像更好实现对数组的代理，就有必要了解相比普通对象，数组到底有何特殊之处。

## 与普通对象的相同点

在 JavaScript 中有两种对象：常规对象和异质对象，而数组就是一个异常质对象。这是因为数组的 [[DefineOwnProperty]] 内部方法与常规对象不同。

换句话说，数组对象除了 [[DefineOwnProperty]] 内部方法之外，其它内部方法的逻辑都与常规对象相同。因此，当实现对数组的代理时，用于代理普通对象的大部分代码可以继续使用：

```js
cons arr = reactive(['foo'])

effect(() => {
  console.log(arr[0])
})

arr[0] = 'bar' // 能够触发响应
```

## 数组的读取与设置操作

事实上，当我们通过索引读取或设置数组元的值时，代理对象的 get/set 拦截函数也会执行。因此我们不需要做任何额外工作，就能够让数组索引的读取和设置操作是响应式的了。

然而数组的操作与普通对象仍然存在不同，下面总结了所有对数组元素或属性的“读取“操作：

* 通过索引访问数组元素值：arr[0]。
* 访问数组的长度：arr.length。
* 使用 for...in 循环遍历数组。
* 使用 for...of 循环遍历数组。
* 不改变原数组的原型方法，如 concat/join/every/some/find/findIndex/includes 等。
  
再来看看对数组元素或属性的设置操作：

* 通过索引修改数组元素值：arr[0] = 'foo'。
* 修改数组长度：arr.length = 100。
* 数组的栈方法：push/pop/shift/unshift。
* 修改原数组的原型方法：splice/fill/sort 等。

除了通过数组索引修改数组元素值这种基本操作之外，数组本身还有很多会修改原数组的原型方法。调用这些方法也属于对数组的操作，有些方法的操作语义是“读取”，有些方法的操作语义是“设置”。当这些操作发生时，也应该正确建立响应联系或触发响应。

## 下一节

下一节中，我们将从通过索引读取或设置数组的元素值开始，实现代理数组。
