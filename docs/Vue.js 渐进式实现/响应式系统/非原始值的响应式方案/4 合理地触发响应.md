# 合理地触发响应
上一节中，我们从规范的角度详细介绍了如何代理对象。

这一节中，我们将进一步讨论如何合理的触发响应。

## 思路
### 仅当值变化时才触发响应
首先来看第一个问题，即当值没有发生变化时，应该不需要触发响应才对。

为了满足需求，我们需要修改 set 拦截函数的代码，在调用 trigger 函数触发响应之前，检查值是否真的发生了变化：
```js{3-5,12-15}
function reactive(obj) {
    return new Proxy(obj, {
        set(target, key, newVal, receiver) {
            // 先获取旧值
            const oldVal = target[key]

            // 如果属性不存在，说明是添加新属性，否则是修改已有属性
            const type = Object.prototype.hasOwnProperty.call(target, key) ? 'SET' : 'ADD'

            const res = Reflect.set(target, key, value, receiver)

            // 比较新值与旧值，只有当它们不全等，并且都不是 NaN 的时候才触发响应
            if (oldVal !== newVal && (oldVal === oldVal || newVal === newVal)) {
                trigger(target, key, type)
            }

            return res
        }
    })
}
```
如上代码所示，我们在 set 拦截函数中先获取旧值，并且在调用 trigger 函数触发更新前比较新值与旧值，只有当它们不全等时才触发响应。

同时我们还对 NaN 进行了特殊处理，因为 NaN !== NaN。因此当新值与旧值都是 NaN 时，我们也不触发响应。

### 访问原型属性


